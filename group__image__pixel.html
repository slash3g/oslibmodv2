<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Pixel access</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__image__pixel.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Pixel access<div class="ingroups"><a class="el" href="group__image.html">Images</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2abc6cfb0fa391142551f86488599289"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga2abc6cfb0fa391142551f86488599289">oslGetImageLine</a>(img, y)&#160;&#160;&#160;((char*)((img)-&gt;data) + (y)*(((img)-&gt;realSizeX * <a class="el" href="group__image__pixel.html#gae84026314c01744128932407470bc75b">osl_pixelWidth</a>[(img)-&gt;pixelFormat])&gt;&gt;3))</td></tr>
<tr class="separator:ga2abc6cfb0fa391142551f86488599289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd9c6315b59af4be74346c54b73f0c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#gaadd9c6315b59af4be74346c54b73f0c1">oslGetImagePixelAddr</a>(img, x, y)&#160;&#160;&#160;((char*)((img)-&gt;data) + ((((y)*(img)-&gt;realSizeX + (x)) * <a class="el" href="group__image__pixel.html#gae84026314c01744128932407470bc75b">osl_pixelWidth</a>[(img)-&gt;pixelFormat])&gt;&gt;3))</td></tr>
<tr class="separator:gaadd9c6315b59af4be74346c54b73f0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaecbb87d882a545576b448252ae50cd9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#gaecbb87d882a545576b448252ae50cd9e">oslUncacheImageData</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr class="separator:gaecbb87d882a545576b448252ae50cd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga789fb4f5321897634fddb3aa14e7d6e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga789fb4f5321897634fddb3aa14e7d6e9">oslUncacheImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr class="separator:ga789fb4f5321897634fddb3aa14e7d6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17750f92f8395b04b76cd58d3332c5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#gaa17750f92f8395b04b76cd58d3332c5d">oslGetImagePixel</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, unsigned int x, unsigned int y)</td></tr>
<tr class="separator:gaa17750f92f8395b04b76cd58d3332c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa20f8d50de53edf75802faf747b2aa66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#gaa20f8d50de53edf75802faf747b2aa66">oslSetImagePixel</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, unsigned int x, unsigned int y, int pixelValue)</td></tr>
<tr class="separator:gaa20f8d50de53edf75802faf747b2aa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85cb0dd8941f90352335474d51fc69f9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga85cb0dd8941f90352335474d51fc69f9">oslGetSwizzledPixelAddr</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, unsigned int x, unsigned int y)</td></tr>
<tr class="separator:ga85cb0dd8941f90352335474d51fc69f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac444b3ad613929f5bce6da775f574197"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#gac444b3ad613929f5bce6da775f574197">oslConvertColor</a> (int pfDst, int pfSrc, int color)</td></tr>
<tr class="separator:gac444b3ad613929f5bce6da775f574197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767b891aec656ada10b5c8163a9d0e96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga767b891aec656ada10b5c8163a9d0e96">oslConvertColorEx</a> (<a class="el" href="struct_o_s_l___p_a_l_e_t_t_e.html">OSL_PALETTE</a> *p, int pfDst, int pfSrc, int color)</td></tr>
<tr class="separator:ga767b891aec656ada10b5c8163a9d0e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e009683f250dbeeeb7d8cb304b58ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga1e009683f250dbeeeb7d8cb304b58ddd">oslLockImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr class="separator:ga1e009683f250dbeeeb7d8cb304b58ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga483de8582f4bdf0ec946e16f0cbd8856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga483de8582f4bdf0ec946e16f0cbd8856">oslUnlockImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr class="separator:ga483de8582f4bdf0ec946e16f0cbd8856"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae84026314c01744128932407470bc75b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#gae84026314c01744128932407470bc75b">osl_pixelWidth</a> []</td></tr>
<tr class="separator:gae84026314c01744128932407470bc75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e1b4c623f2ee9591b1b5ee098decb9"><td class="memItemLeft" align="right" valign="top">const u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga99e1b4c623f2ee9591b1b5ee098decb9">osl_paletteSizes</a> []</td></tr>
<tr class="separator:ga99e1b4c623f2ee9591b1b5ee098decb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Low level access to images. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga2abc6cfb0fa391142551f86488599289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslGetImageLine</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">img, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((char*)((img)-&gt;data) + (y)*(((img)-&gt;realSizeX * <a class="el" href="group__image__pixel.html#gae84026314c01744128932407470bc75b">osl_pixelWidth</a>[(img)-&gt;pixelFormat])&gt;&gt;3))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the beginning (left border) of an image line. This address can be used to access image raw data. Please note that when doing this, you'll have to respect the pixelformat of the image! If the image is 16 bits (4444, 5551 or 5650) then use a u16 pointer and appropriate RGBxx macros.</p>
<p>Here is an example which fills one line: </p><div class="fragment"><div class="line"><span class="comment">//Create a 15-bit image (16-bit pixel width as 1 alpha bit is added).</span></div>
<div class="line"><a class="code" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img = <a class="code" href="group__image__creation.html#ga120ad0461bc8369f9431bff653d25217">oslCreateImage</a>(32, 32, <a class="code" href="group__image.html#gga163a37d9c3999633b0dc387e15453845a40b7f6fda376d3390a38f2d2629a39f7">OSL_IN_RAM</a>, <a class="code" href="group__image.html#ggab3528cc93235f479e65017b9cc0a2259a5a0a8c1193ea60a42d6c6dcd6fb62f18">OSL_PF_5551</a>);</div>
<div class="line"><span class="comment">//Get a pointer to the 4th line (0 is the first, 1 the second, ...)</span></div>
<div class="line">u16 *data = (u16*)<a class="code" href="group__image__pixel.html#ga2abc6cfb0fa391142551f86488599289">oslGetImageLine</a>(img, 3);</div>
<div class="line"><span class="comment">//Loop index variable</span></div>
<div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="comment">//From the beginning to the end of the line...</span></div>
<div class="line"><span class="keywordflow">for</span> (i=0;i&lt;img-&gt;sizeX;i++)              {</div>
<div class="line">        <span class="comment">//Set this pixel to bright red</span></div>
<div class="line">         *data = <a class="code" href="group__drawing__color.html#gaac51b4482ade52ca41195dc5840b02ae">RGBA15</a>(255, 0, 0, 255);</div>
<div class="line">        <span class="comment">//Point to the next pixel</span></div>
<div class="line">        data++;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaadd9c6315b59af4be74346c54b73f0c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslGetImagePixelAddr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">img, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((char*)((img)-&gt;data) + ((((y)*(img)-&gt;realSizeX + (x)) * <a class="el" href="group__image__pixel.html#gae84026314c01744128932407470bc75b">osl_pixelWidth</a>[(img)-&gt;pixelFormat])&gt;&gt;3))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the address of a single pixel of an image. Please note that this works only for 8 to 32 bits pixel types, but not for 4 bits, as the byte is the smallest unit you can work with, and in this case a byte contains 2 pixels. In case of 4 bits, a pointer to the corresponding pixel pair (byte) will be returned, and you'll have to use masks to handle this correctly.</p>
<p>Here is an (untested) example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> setPixel(<a class="code" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> value)          {</div>
<div class="line">        u8 *data = oslGetImagePixelAdr(x, y);</div>
<div class="line"></div>
<div class="line">        <span class="comment">//The pixel value can&#39;t be larger than 4 bits, else we would overflow on the next pixel, messing up the display.</span></div>
<div class="line">        value &amp;= 0xf;</div>
<div class="line"></div>
<div class="line">        <span class="comment">//First method: is x even?</span></div>
<div class="line">        <span class="keywordflow">if</span> (x &amp; 1)              {</div>
<div class="line">                <span class="comment">//Mask out the last 4 bits</span></div>
<div class="line">                data &amp;= 0x0f;</div>
<div class="line">                <span class="comment">//Write to the last 4 bits</span></div>
<div class="line">                data |= value &lt;&lt; 4;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span>    {</div>
<div class="line">                <span class="comment">//Mask out the first 4 bits</span></div>
<div class="line">                data &amp;= 0xf0;</div>
<div class="line">                <span class="comment">//Write to the first 4 bits</span></div>
<div class="line">                data |= value;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">//Second method: directly integrate the parity checking</span></div>
<div class="line">        data &amp;= ~(15 &lt;&lt; ((x &amp; 1) &lt;&lt; 2));</div>
<div class="line">        data |= value &lt;&lt; ((x &amp; 1) &lt;&lt; 2);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaecbb87d882a545576b448252ae50cd9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslUncacheImageData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flushes the image data from the cache. Never forget to call this after you've modified an image in a cached way (by default all the following routines do). See oslUncacheData for more information.</p>
<p>Note: this routine does not flush the associated image palette data! Call oslUncacheImage instead if you need it! </p>

</div>
</div>
<a class="anchor" id="ga789fb4f5321897634fddb3aa14e7d6e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslUncacheImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uncache a whole image, including its associated palette (image-&gt;palette). </p>

</div>
</div>
<a class="anchor" id="gaa17750f92f8395b04b76cd58d3332c5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int oslGetImagePixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>High-level routine which reads a single pixel on an image. Beware, caching is enabled, so after finished reading and/or writing pixels to an image, please take care to uncache your image! The best and cleaner way to do it is to use <a class="el" href="group__image__pixel.html#ga1e009683f250dbeeeb7d8cb304b58ddd">oslLockImage</a> and <a class="el" href="group__image__pixel.html#ga483de8582f4bdf0ec946e16f0cbd8856">oslUnlockImage</a>. See <a class="el" href="group__image__pixel.html#gaa17750f92f8395b04b76cd58d3332c5d">oslGetImagePixel</a> for an example. </p><pre class="fragment">    \return
            The value of the pixel at that position. The value depends on the pixelformat, it can be a palette entry number if the image is paletted, or a color in the format of the image (so you may have
            to convert it depending on what you'd like).
</pre><div class="fragment"><div class="line"><span class="comment">//Get a 32 bit (OSL_PF_8888) color for the pixel at x, y, whatever its pixelformat is.</span></div>
<div class="line">pixel = <a class="code" href="group__image__pixel.html#ga767b891aec656ada10b5c8163a9d0e96">oslConvertColorEx</a>(yourImage-&gt;palette, <a class="code" href="group__image.html#ggab3528cc93235f479e65017b9cc0a2259a1aeaeefa432a52c184d8795655b4c525">OSL_PF_8888</a>, yourImage-&gt;pixelFormat, <a class="code" href="group__image__pixel.html#gaa17750f92f8395b04b76cd58d3332c5d">oslGetImagePixel</a>(yourImage, x, y));</div>
</div><!-- fragment --><p>Note: This routine also works for swizzled images!</p>
<p><b>Note:</b> this routine is rather slow, you should consider raw access if you need good performance. </p>

</div>
</div>
<a class="anchor" id="gaa20f8d50de53edf75802faf747b2aa66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslSetImagePixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixelValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a pixel on the image. Same remarks as for oslGetImagePixel apply. The value is in the destination format of the image (so, either a palette entry or a color in the good format). Use conversions if needed, as shown in the example above. Here is another example that does calculation on every pixel of an image.</p>
<div class="fragment"><div class="line"><span class="comment">//Before doing low level operations on an image, we first need to lock it, it takes care of low level cache operations.</span></div>
<div class="line"><a class="code" href="group__image__pixel.html#ga1e009683f250dbeeeb7d8cb304b58ddd">oslLockImage</a>(image);</div>
<div class="line">{</div>
<div class="line">        <span class="comment">//The {...} block is just for estethic, not necessary</span></div>
<div class="line">        <span class="keywordflow">for</span> (j=0;j&lt;image-&gt;sizeY;j++)            {</div>
<div class="line">                <span class="keywordflow">for</span> (i=0;i&lt;image-&gt;sizeX;i++)            {</div>
<div class="line">                        <span class="comment">//Get a pixel of the image (depends on its pixelformat, here we assume it&#39;s 8888)</span></div>
<div class="line">                        u32 pixel = <a class="code" href="group__image__pixel.html#gaa17750f92f8395b04b76cd58d3332c5d">oslGetImagePixel</a>(image, i, j);</div>
<div class="line">                        <span class="comment">//Mask out the green and blue components</span></div>
<div class="line">                        <a class="code" href="group__image__pixel.html#gaa20f8d50de53edf75802faf747b2aa66">oslSetImagePixel</a>(image, i, j, pixel &amp; 0xff0000ff);</div>
<div class="line">                }</div>
<div class="line">        }</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__image__pixel.html#ga483de8582f4bdf0ec946e16f0cbd8856">oslUnlockImage</a>(image);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga85cb0dd8941f90352335474d51fc69f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* oslGetSwizzledPixelAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of a pixel, working even if the image is swizzled. This implementation is slower but works in every case. </p>

</div>
</div>
<a class="anchor" id="gac444b3ad613929f5bce6da775f574197"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int oslConvertColor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pfDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pfSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfDst</td><td>Destination pixel format. </td></tr>
    <tr><td class="paramname">pfSrc</td><td>Source pixel format. </td></tr>
    <tr><td class="paramname">color</td><td>Color (in the source pixel format). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga767b891aec656ada10b5c8163a9d0e96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int oslConvertColorEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___p_a_l_e_t_t_e.html">OSL_PALETTE</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pfDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pfSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a color but using a palette if either the source or destination pixel format are paletted. See oslGetImagePixel for an example of use. </p>

</div>
</div>
<a class="anchor" id="ga1e009683f250dbeeeb7d8cb304b58ddd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslLockImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks an image, so that you can access it. Althrough not necessary, this is a good thing to do because it will automatically handle drawing to the drawbuffer, uncaching the image when finished and flushing the texture cache to avoid render errors when an image is modified while it's being drawn. </p><div class="fragment"><div class="line"><span class="comment">//Lock the image</span></div>
<div class="line"><a class="code" href="group__image__pixel.html#ga1e009683f250dbeeeb7d8cb304b58ddd">oslLockImage</a>(myImage);</div>
<div class="line">{</div>
<div class="line">        <span class="comment">//Do some software access to the image</span></div>
<div class="line">        u16 *ptr = (u16*)myImage-&gt;data;</div>
<div class="line">         *ptr = 0;</div>
<div class="line">}</div>
<div class="line"><span class="comment">//Unlock it after having finished</span></div>
<div class="line"><a class="code" href="group__image__pixel.html#ga483de8582f4bdf0ec946e16f0cbd8856">oslUnlockImage</a>(myImage);</div>
<div class="line"></div>
<div class="line"><span class="comment">//We can now draw it!</span></div>
<div class="line"><a class="code" href="group__image__drawing.html#gaf6b7b3f250d1fd2d961d55686528a276">oslDrawImage</a>(myImage);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga483de8582f4bdf0ec946e16f0cbd8856"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslUnlockImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlock the image after you've finished with it. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gae84026314c01744128932407470bc75b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int osl_pixelWidth[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of pixel widths (in bits) for each pixel format. </p>

</div>
</div>
<a class="anchor" id="ga99e1b4c623f2ee9591b1b5ee098decb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const u8 osl_paletteSizes[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of palette sizes (in powers of two). For non-paletted formats, it is zero. Else you can get the palette size by doing 1 &lt;&lt; osl_paletteSizes[pixelFormat]. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
